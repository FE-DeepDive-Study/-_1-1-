# 쉽게 쓰는 타입스크립트 4~5 

### 4.2.1. `node_modules` 폴더

`node_modules` 폴더에는 라이브러리가 설치되어 있으며, NPM 기반 웹 애플리케이션을 실행 시 필요

### 4.2.3. `.eslintrc.js` 파일

.eslintrc.js 파일은 ESLint 설정 파일로, 추가 세팅으로 타입스크립트 코드까지 검사 가능

### 4.2.4. `package.json` 파일

* `package.json` 파일은 NPM 설정 파일
* 프로젝트 이름, 버전, 라이선스 등 프로젝트와 관련된 기본 정보 포함 (수정 가능)
* 프로젝트 실행 및 로컬 개발 시 필요한 라이브러리 목록 저장

* devDependencies: 프로젝트 로컬 개발 시 사용 가능한 라이브러리 목록 (로컬에서 사용할 개발서버, 코드 문법 검사 도구 등에 해당)

### 4.2.5. `package-lock.json` 파일

* `package-lock,json` 파일은 dependencies나 devDependencies 목록에 명시된 라이브러리 설치 시 필요한 부수 라이브러리의 버전 관리 
* `package.json` 라이브러리 설치 시 자동 생성
* `package-lock.json` 파일의 내용은 수정 X

### 4.2.6. `tsconfig.json` 파일

`tsconfig.json` 파일은 타입스크립트 설정 파일로 컴파일을 돌릴 파일 목록 및 배제할 목록, 그리고 구체적인 컴파일러 동작 지시 등 다양한 옵션 지정 가능

* compiler options: 타입스크립트 컴파일 시 세부 동작 지정 가능한 옵션
* allowJs: 타입스크립트 컴파일 시 자바스크립트 파일 컴파일 여부 지정 가능 옵션
* checkJs: 주로 allowJs 옵션과 같이 사용, 프로젝트 내 자바스크립트 파일에서타입스크립트 컴파일 규칙 사용 여부 설정. (자바스크립트 파일의 맨 위에 //@ts-check 삽입과 동일 효과)
* nolmplicitAny: false 선택 시 타입스크립트 코드 타입 미지정된 부분을 암묵적으로 any로 추론하는 옵션. true 값을 넣으면 타입이 지정 되어 있지 않은 자바스크립트 코드 경고 표시
* include: 타입스크립트 컴파일 대상 경로 지정, `../src/**/*`는 src 폴더 아래의모든 파일에서 타입스크립트 컴파일 실행하겠다는 의미

### 4.5.1. 함수의 반환 타입 정의

* ‘Missing return type on function’는 함수의 반환 타입이 설정되어 있지 않은 상태
* ESLint 설정 파일에 있는 @ typescript-eslint/explicit-function-return-type 설정 값이 해당 규칙을 검사하는 값이며, 함수의 반환 타입이 설정되어 있지 않을 때 메시지 표시

* VSC는 내부적으로 타입스크립트 코드 분석 후  알맞은 타입을 사용자에게 제시
* void는 함수의 반환값이 없을 때 지정하는 타입

### 4.5.2. 할 일 목록 변수인 todoItems 타입 정의

타입 지정 시 코드 미실행 상태에서도 코드 편집 레벨에서 에러의 사전 체크가 가능하여 에러 조기 방지 효과가 있음 

### 4.5.3. 함수 파라미터 타입 구체화

* 데이터 성격에 가장 적합한 타입으로 범위를 좁혀 주는 것이 바로 타입을 구체화한다는 것
* 타입 구체화에 익숙해지기 위해서는 기존 코드에서 any 타입 제거 후 함수의 반환 타입이 어떤 타입으로 추론되는지 확인하는 작업을 진행하는 것을 추천 

### 4.5.4. addTwoTodoItems( ) 함수 구현

구체적인 파라미터 타입 정의를 통해 함수에 원하는 데이터를 알맞게 넘겨줄 수 있음

### 4.5.5. 반복되는 타입 코드 줄이기

* 인터페이스(interface)를 통해 반복되는 타입의 작성을 줄일 수 있음
* 타입 작성에 들이는 에너지를 줄일 수 있어 함수 동작 코드 작성에 더 많은 기여가 가능하며 코드 가독성도 개선시킬 수 있음

## 5.1. 인터페이스란?

* 인터페이스(interface)는 객체 타입을 정의 시 사용하는 문법

* 인터페이스로 타입 정의가 가능한 범위
• 객체의 속성과 속성타입
• 함수의 파라미터와 반환타입
• 함수의 스펙(파라미터 개수와 반환값 여부 등)
• 배열과 객체를 접근하는방식
• 클래스

## 5.2. 인터페이스를 이용한 객체 타입 정의

* 인터페이스 내 정의된 타입과 객체 속성의 타입이 맞지 않을 때 에러 발생
* 인터페이스에 정의하지 않은 속성이 추가로 정의 되었을 때 에러 발생

* 인터페이스를 통해 객체의 속성과 들어갈 데이터 타입을 정확하게 정의하고 에러를 줄일 수 있음

## 5.3. 인터페이스를 이용한 함수 타입 정의

* 인터페이스는 객체의 타입을 정의할 때 사용되므로 객체가 활용되는 모든 곳에 인터페이스 활용이 가능. 객체는 함수의 파라미터, 함수 반환값 등에도 사용 가능

## 5.4. 인터페이스의 옵션 속성

* 옵션 속성: 인터페이스 속성에 ?를 추가하여 옵션 속성으로 지정
* 상황에 따라서 유연하게 인터페이스 속성의 사용 여부를 결정하기 위해 사용

## 5.5. 인터페이스 상속

* 인터페이스의 상속으로 타입 정의를 확장이 가능
* 상속은 객체 간 관계를 형성하는 방법으로, 상위(부모) 클래스의 내용을 하위(하위)래스가 물려받아 사용하거나 확장하는 기법

* `extends`를 사용한 클래스의 속성과 메서드 모두 사용 가능
* 상위 클래스에 정의된 속성을 하위 클래스에서 접근하여 사용 가능

### 5.5.1. 인터페이스의 상속이란?

클래스 상속 시 `extends` 예약어를 사용했듯, 인터페이스 상속 시에도 동일하게 extends 예약어를 사용

### 5.5.2. 인터페이스를 상속할 때 참고 사항

* 인터페이스의 타입을 하위 인터페이스에서 상속받아 타입을 정의 시에는 상위 인터페이스의 타입에서 정의된 타입을 사용해야 함

* 인터페이스를 상속하여 사용할 때는 상위 인터페이스에 정의된 타입을 자식 인터페이스에서 모두 보장해야 함

* 상속은 여러 번 가능하여 인터페이스가 3개일 경우 3개에 제공하는 속성을 모두 타입에 맞게 선언해 주어야 함

## 5.6. 인터페이스를 이용한 인덱싱 타입 정의

* 인터페이스로 객체와 배열의 인덱싱 타입 정의가 가능 
* 인덱싱이란 객체의 특정 속성을 접근하거나 배열의 인덱스로 특정 요소에 접근하는 동작을 의미

* 예를 들어 `user['name']` 형태로 객체의 특정 속성에 접근하거나 `companies[0]` 형태로 배열 의 특정 요소에 접근하는 것

### 5.6.1. 배열 인덱싱 타입 정의

* 배열을 인덱싱 시 인터페이스로 인덱스와 요소의 타입을 정의 가능

* `[index: number]` 라는 코드는 어떤 number도 모두 속성의 이름이 될 수 있다는 의미
* `[index: number]: string` 는 속성 이름은 number이고, 그 속성 값으로 문자열 타입이 와야 한다는 의미. 즉, 배열의 인덱스 타입이 `[index: number]` 가 되고, 인덱스로 접근한 요소의 타입이 string

* `[index: string]: string` 에러: 원래 배열의 인덱스는 숫자여야 접근이 가능하나, 문자열로 인덱스 타입을 강제하여 배열 정의에 위배됨.

### 5.6.2. 객체 인덱싱 타입 정의

객체의 속성에 접근하는 방법은 `salary['junior']` 또는 `salary.junior` 모두 가능하나, 속성 이름에 숫자나 - 등 특수 기호 삽입 시 `.junior` 방식으로 접근할 수 없으므로 `['junior']` 방식으로 접근해야 함

### 5.6.3. 인덱스 시그니처란?

* 인덱스 시그니처(index signature): 속성 이름을 명시하지 않고 속성 이름의 타입과 속성 값의 타입을 정의하는 문법, 객체의 속성 타입을 유연하게 정의할 때도 사용됨

* 인터페이스를 여러 번 수정해야 하는 공통적인 반복 작업이 진행되어야 할 때 인덱스 시그니처 방식을 통해 속성 이름의 타입과 속성 값의 타입을 공통적으로 정의

```
interface SalaryInfo{
   [level: string]: string;
}
```

### 5.6.4. 인덱스 시그니처는 언제 쓸까?

* 객체의 속성 이름과 개수가 구체적으로 정의되어 있을 경우, 인터페이스 내 속성명과 속성 값 타입 명시가 더 효과적일 수 있음
* 인덱스 시그니처 적용 시에는 구체적으로 어떤 속성이 제공될지 알 수 없어 코드 자동 완성이 되지 않음

* 객체의 속성 이름과 속성 값이 정해져 있는 경우에는 속성 이름과 속성 값 타입을 명시해서 정의하고, 속성 이름은 미정이나 속성 이름의 타입과 값의 타입을 아는 경우 인덱스 시그니처 사용