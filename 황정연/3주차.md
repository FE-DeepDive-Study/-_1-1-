# 쉽게 시작하는 타입스크립트 6~8

## 6. 연산자를 사용한 타입 정의

자바스크립트 OR 연산자( || )와 AND 연산자(&&)의 |와 &를 사용하여 OR을 의미하는 유니언 타입( | )과 타입 2개를 하나로 합친다는 AND의 인터섹션 타입(&)으로 정의

## 6.1. 유니언 타입

유니언 타입(union type)은 자바스크립트 OR 연산자의 || 를이용하여 여러 개의 타입 중 1개를 사용하겠다 고 선언하는 방식

```
function logText ( text:string | number ) {
console.log(text);
}
```

## 6.2. 유니언 타입의 장점

* 타입이 다를 경우 동일한 동작을 행하는 함수를 추가로 작성하여 관리해야 하는 불편함을 줄이기 위해 유니언 타입을 사용하여 함수의 코드 중복을 줄일 수 있음

* 유니언 타입을 `string | number`로 적용 시 각 타입에서 공통적으로 제공하는toString() 등의 메서드를 자동완성 할 수 있으나, any 타입으로 지정할 시에는 자동 완성 기능 사용 불가하여 오탈자 발생 시에도 에러의 사전 발견이 어려움

## 6.3. 유니언 타입을 사용할 때 주의할 점

```
function introduce(someone: Person | Developer) {
console.log(someone);
}
```

* 타입스크립트 입장에서는 함수의 파라미터에 유니언 타입을 사용 시 함수에 어떤 값이 들어올지 알 수 없으므로 가장 안전한 방식으로 타입의 속성과 API를 자동 완성

* 함수 내부에서 파라미터 타입의 종류에 따라 특정 로직을 실행하고 싶다면 in 연산자를 사용해서 로직을 작성

* `in` 연산자: 객체에 특정 속성이 있는지 확인하는 자바스크립트 연산자

```
function introduce(someone:Person | Developer) {
   if ('age' in someone) {
   console.log(someone.age);
   return;
   }
   if ('skill' in someone) {
   console.log(someone.skill);
   return;
   }
}
```

* 함수의 파라미터에 유니언 타입을 선언하면 함수 안에서는 두 타입의 공통 속성과 메서드만 자동 완성
* 특정 타입의 속성과 메서드를 사용하고 싶다면 `typeof`나 `in` 연산자를 사용하여 타입을 구분한 후 코드를 작성하는 타입 가드를 동작하도록 하는 것이 필요

## 6.4. 인터섹션 타입

* 인터섹션 타입(intersection type, &)은 타입 2개를 하나로 합쳐서 사용할 수 있는 타입으로, 보통 인터페이스 2개를 합치거나 타입 정의 여러 개를 하나로 합칠 때 사용

* 함수의 파라미터에 인터페이스를 인터섹션 타입(&)으로 정의 시 두 타입의 속성 모두 사용 가능
* 함수를 호출 시에는 두 속성을 가진 객체를 인자로 넘길수 있으나 넘기는 객체의 속성 중 하나라도 누락되거나, 속성에 오탈자가 발생한 경우 에러 발생

## 7.1. 타입 별칭이란?

* 타입 별칭(type alias): 특정 타입이나 인터페이스 등을 참조할 수 있는 타입 변수
* 타입에 의미를 부여해서 별도의 이름으로 부르는 것이며, 변수와 같이 해당 타입이 어떤 역할을 하는지 이름을 짓고 싶을 때나 여러 번 반복되는 타입을 변수화해서 쉽게 표기하고 싶을 때 사용

* 타입 표기 방식을 이용하여 `string` 타입에 타입 별칭을 적용 시 사용할 타입이 구체적으로 어떤 의미를 지니는지 알 수 있음
```
type MyName = string;
var capt: MyName = "캡틴";
```

* 또한 반복되는 타입 코드를 줄여 줄 수 있다는 것이 가장 큰 장점이며, 아래의 경우 `string | number` 타입이 메시지에 사용되는 타입이라는 것을 의미해주기도 함
```
type MyMessage = string | number;

function logText(text: MyMessage) {
//...
}

var message: MyMessage = "안녕하세요";
logText(message);
```

* 추가로, 타입 변수라는 이름을 가지고 있으나 타입 선언 후 다시 다른 타입으로의 할당은 불가능 

```
type MyName = string;
type MyName = number; // X, 에러 발생
```

## 7.2. 타입 별칭과 인터페이스의 차이점

```
// 타입 별칭
type User = {
id :string; name:string;
}

// 인터페이스
interface User { 
id :string; name:string;
}
```

### 7.2.1. 코드 에디터에서 표기 방식 차이

* 코드 에디터에 표시되는 정보는 우선 타입 별칭에 마우스 커서를 올리면 타입 정보가 객체의 형태로 미리보기 화면에 표시됨
* 인터페이스 코드를 작성하고 미리보기 화면을 확인하면 interface 변수명으로만 표시

따라서 변수에 연결된 타입이 구체적으로 어떤 모양인지 파악이 필요할 때에는 타입 별칭을 사용하는 것이 좋음

### 7.2.2. 사용할 수 있는 타입의 차이

* 타입 별칭은 인터페이스로 정의 할 수 없는 일반 타입이나 유니언 타입, 인터섹션 타입 등에 사용
* 또한 제네릭이나 유틸리티 타입 등 다양한 타입에 사용 가능
```
type ID = string;
type Product = TShirt | Shoes;
type Teacher = Person & Adult;
```

* 인터페이스는 주로 객체의 타입을 정의하는 데 사용되며, 터페이스와 타입 별칭의 정의를 함께 사용할 수도 있음
```
interface Person { 
name: string;
age: number;
}
type Adult = {
old: boolean;
}
type Teacher = Person & Adult;
```

### 7.2.3. 타입 확장 관점에서 차이

* 타입 확장: 이미 정의되어 있는 타입들을 조합해서 더 큰 의미의 타입을 생성하는 것

* 타입 별칭은 인터섹션 타입(&)으로 객체 타입을 2개 합쳐 사용

* 인터페이스는 타입 확장 시 상속이라는 개념을 이용
* `extends` 라는 키워드를 시용해서 부모 인터페이스의 타입을 자식 인터페이스에 상속하여 사용 가능
* 인터페이스의 선언 병합(declaration merging): 기존에 선언된 인터페이스와 동일한 이름으로 인터페이스를 선언 시 해당 이름으로 인터페이스에 정의된 모든 타입을 합쳐버리는 성질

## 7.3. 타입 별칭은 언제 쓰는 것이 좋을까?

* 실 사용 시 타입 별칭으로만 타입 정의가 가능한 곳에서는 타입 별칭을 사용하고, 백엔드와의 인터페이스를 정의하는 곳에서는 인터페이스를 사용하는 것으로 방향성이 나오게 됨

### 7.3.1. 타입 별칭으로만 정의할 수 있는 타입들

* 타입 별칭으로만 정의할 수 있는 타입: 주요 데이터 타입, 인터섹션, 유니언 타입
* 제네릭(generic), 유틸리티 타입(utility type), 맵드 타입 (mapped type)과도 연동하여 사용이 가능

* 인터페이스는 객체 타입을 정의할 때 시용하는 타입

* 제네릭: 인터페이스와 타입 별칭에 모두 사용 가능
* 유틸리티 타입, 맵드 타입: 타입 별칭으로만 정의 가능 (두 타입 모두 기존에 정의된 타입을 변경하거나 일부만 활용할 때 타입 별칭 사용)

### 7.3.2. 백엔드와의 인터페이스 정의

* 백엔드에서 프런트엔드로 어떻게 데이터를 넘길지 정의하는 작업이 즉, 인터페이스를 정의한다고 하는 것
* BE -> FE 인터페이스: 타입스크립트 내에서 쓰이는 `interface` 예약어가 아닌 영역 간 접점(데이터)을 서로 맞추는 작업을 의미

* 화면에 노출해야 하는 데이터 구조 내 객체의 속성에 추가가 필요하거나 다른 객체 정보와 결합하여 표시되어야 할 경우, 유연하게 타입 확장이 필요하므로 타입 별칭보다는 선언 병합 등을 이용해 인터페이스로 정의하는 것이 더 수월

## 8.1. 이넘이란?

* 이넘(enum): 특정 값의 집합을 의미하는 데이터 타입이자 상수 집합이라고도 표현

* 상수: 변하지 않는 고정 값이자 단순히 고정된 값을 저장 하는 것뿐만이 아닌 해당 값이 어떤 의미를 갖는지 알려 줌으로써 가독성을 높여줌

* 이러한 여러 개의 상수를 하나의 단위로 묶으면 이넘이 되며, 비슷한 성격이나 같은 범주에 있는 상수를 하나로 묶어 더 큰 단위의 상수로 만드는 것이 바로 이넘의 역할

```
enum ShoesBrand {
Nike,
Adidas,
NewBalance
}
```

* 객체의 속성에 접근하듯이 이넘명을 작성, 접근자를 이용하여 속성 이름을 붙임

## 8.2. 숫자형 이넘

* 이넘에 선언된 속성은 기본적으로 숫자 값을 가지며, 숫자로 지정 되는 이유는 타입스크립트의 내부 규칙 때문임

```
Direction[Direction["Up"] = 0] = "Up";

// 상하 동일

Direction.Up = 0;
Direction[0] = "Up";
```

* 리버스 매핑(reverse mapping): 이넘의 속성과 값이 거꾸로 연결되어 할당되는 것

* 이넘 규칙: 첫 번째 속성의 시작 값을 변경하더 라도 순서대로 선언된 이넘 속성의 값은 1씩 증가
* 그러나 실제 코드를 작성할 때는 컴파일 결과를 보지 않고도 값을 빠르게 파악하는 것이 필요하므로 오히려 명시적으로 값을 설정하는 것이 좋음
```
enum Direction { Up = 10,
Down =11,
Left = 12,
Right = 13
}
```

## 8.3. 문자형 이넘

* 문자형 이넘: 이넘의 속성 값에 문자열을 연결한 이넘을 의미, 숫자형 이넘과는 다르게 모든 속성 값을 다 문자열로 지정해 주어야 하며 선언된 속성 순서대 로 값이 증가하는 규칙이 없음

* 숫자로 관리되기보다는 문자열로 관리되는 것이 더 명시적
* 따라서 실무에서는 이넘 값을 숫자로 관리하기보다 문자열로 관리하는 사례가 더 많으며, 속성 이름과 값을 동일한 문자열로 관리하는 것도 일반적인 코딩 규칙이라고 할 수 있음

### 8.4.1. 혼합 이넘

```
enum Answer {
Yes = 'Yes' ,
No = 1
}
```

* 숫자와 문자열을 섞어서 선언할 수 있고 코드상으로는 문제가 없으나, 관리의 측면에서 이넘 값은 일괄되게 숫자나 문자열 둘 중 하나의 데이터 타입으로 통일시키는 것이 좋음

### 8.4.2. 다양한 이넘 속성 값 정의 방식

* 먼저 선언되어 있는 이넘의 속성 활용 가능
* 연산자 사용이 가능하여 계산한 값을 속성 값으로 할당할 수 있음
* 문자열의 길이를 뜻하는 .length를 사용하여 속성 값 정의 가능

* 이넘 속성 값을 할당 시 연산자 등을 활용할 수 있지만 활용도는 높지 않으며, 보통 각 속성 이름만 보고도 값을 바로 추측할 수 있는 문자 열 값을 많이 사용

### 8.4.3. const 이넘

* const 이넘: 이넘을 선언할 때 앞에 const를 붙인 이넘이며, const를 이넘 앞에 붙이는 이유는 컴파일 결과물의 코드양을 줄이기 위해서임

* 이넘을 코드에서 활용하려면 객체를 내부적으로 선언해서 이넘 속성 값들을 연결하는 작업이 필요하여 이넘 코드는 컴파일될 때 객체가 이넘의 속성 이름과 값을 연결해주는 객체를 생성
* 그러나 const 이넘은 컴파일 시 연결용 객체를 생성하지 않고 이넘이 사용되는 곳에서 속성 값을 바로 연결해주므로 컴파일했을 때 아무 코드도 생성되지 않는 것

* const 이넘은 컴파일했을 때 코드양을 줄여 주지만, 다양한 속성 값 정의 방식을 사용할 수 없어 항상 속성 에 고정값만 넣어 주어야 함